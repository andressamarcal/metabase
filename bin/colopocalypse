#!./node_modules/.bin/babel-node

const glob = require("glob");
const fs = require("fs");
const path = require("path");
const Color = require("color");
const colorDiff = require("color-diff");

const POSTCSS_CONFIG = require("../postcss.config.js");
const cssVariables =
  POSTCSS_CONFIG.plugins["postcss-cssnext"].features.customProperties.variables;
console.log(cssVariables);

// these are a bit liberal regexes but that's probably ok
const COLOR_REGEX = /(#[a-fA-F0-9]{3}([a-fA-F0-9]{3})?|(rgb|hsl)a?\(\s*\d+\s*(,\s*\d+(\.\d+)?%?\s*){2,3}\))/g;
const COLOR_REGEX_WITH_LINE = /(#[a-fA-F0-9]{3}([a-fA-F0-9]{3})?|(rgb|hsl)a?\(\s*\d+\s*(,\s*\d+(\.\d+)?%?\s*){2,3}\)).*/g;

const CSS_SIMPLE_VAR_REGEX = /^var\(([^)]+)\)$/;
const CSS_COLOR_VAR_REGEX = /^color\(var\(([^)]+)\) shade\(([^)]+)\)\)$/;
const CSS_VAR_REGEX = /var\([^)]+\)|color\(var\([^)]+\) shade\([^)]+\)\)/g;

const FILE_GLOB = process.argv[2] || "frontend/**/*.{css,js,jsx}";
const FILE_GLOB_IGNORE = [
  // "**/metabase/lib/colors.js"
];

const candidates = {};

function addCandidate(colorName, baseColor, tints = [1]) {
  for (const tint of tints) {
    if (tint === 1) {
      candidates[colorName] = baseColor.rgb();
    } else {
      candidates[`${colorName}-${tint * 100}`] = Color("white")
        .mix(baseColor, tint)
        .rgb();
    }
  }
}

// add candidate colors, currently various tints of normal, saturated, and desaturated
// const colors = require("../frontend/src/metabase/lib/colors");
// const tints = [1, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.05, 0.02];
//
// for (const [colorName, color] of Object.entries(colors.normal)) {
//   addCandidate(colorName, Color(color), tints);
// }
// for (const [colorName, color] of Object.entries(colors.saturated)) {
//   addCandidate(colorName + "-saturated", Color(color), tints);
// }
// for (const [colorName, color] of Object.entries(colors.desaturated)) {
//   addCandidate(colorName + "-desaturated", Color(color), tints);
// }

addCandidate("brand", Color("#509EE3"));
addCandidate("accent1", Color("#9CC177"));
addCandidate("accent2", Color("#A989C5"));
addCandidate("accent3", Color("#EF8C8C"));
addCandidate("accent4", Color("#F9D45C"));
addCandidate("accent5", Color("#F1B556"));
addCandidate("accent6", Color("#A6E7F3"));
addCandidate("accent7", Color("#7172AD"));

addCandidate("white", Color("#FFFFFF"));

addCandidate("text-dark", Color("#2E353B"));
addCandidate("text-medium", Color("#93A1AB"));
addCandidate("text-light", Color("#DCE1E4"));

addCandidate("bg-dark", Color("#EDF2F5"));
addCandidate("bg-light", Color("#F9FBFC"));

addCandidate("shadow", Color("#F4F5F6"));
addCandidate("border", Color("#D7DBDE"));

addCandidate("success", Color("#84BB4C"));
addCandidate("error", Color("#ED6E6E"));
addCandidate("warning", Color("#F9CF48"));

// maybe this should weight the difference in hue more heavily?
// function colorDifference(colorA, colorB) {
//   return Math.sqrt(
//     Math.pow(colorA.red() - colorB.red(), 2) +
//       Math.pow(colorA.green() - colorB.green(), 2) +
//       Math.pow(colorA.blue() - colorB.blue(), 2),
//   );
// }

// function getBestCandidate(color) {
//   let bestName;
//   let bestDistance = Infinity;
//   for (const [candidateName, candidate] of Object.entries(candidates)) {
//     const distance = colorDifference(color, candidate);
//     if (distance < bestDistance) {
//       bestName = candidateName;
//       bestDistance = distance;
//     }
//   }
//   let bestColor = candidates[bestName];
//   if (color.alpha() < 1) {
//     bestColor = bestColor.alpha(color.alpha());
//   }
//   // console.log(color.string(), "=>", bestName, bestColor.string(), bestDistance);
//   return [bestName, bestColor];
// }

const palette = Object.entries(candidates).map(([name, color]) => ({
  name,
  color,
  R: color.red(),
  G: color.green(),
  B: color.blue(),
}));

function getBestCandidate(color) {
  const closest = colorDiff.closest(
    { R: color.red(), G: color.green(), B: color.blue() },
    palette,
  );
  let bestName = closest.name;
  let bestColor = closest.color;
  if (color.alpha() < 1) {
    bestColor = bestColor.alpha(color.alpha());
  }
  return [bestName, bestColor];
}

function replaceSimpleColorValues(content, isCSS) {
  return content.replace(COLOR_REGEX, color => {
    const [newColorName, newColor] = getBestCandidate(Color(color));
    if (color === newColor.string()) {
      console.log(color, `(unchanged: ${newColorName})`);
    } else {
      console.log(color, "=>", newColor.string(), `(${newColorName})`);
    }
    return newColor.string();
  });
}

function resolveCSSVariableColor(value) {
  try {
    if (value) {
      if (COLOR_REGEX.test(value)) {
        return Color(value);
      }
      const colorVarMatch = value.match(CSS_COLOR_VAR_REGEX);
      if (colorVarMatch) {
        const color = resolveCSSVariableColor(cssVariables[colorVarMatch[1]]);
        if (color) {
          const shade = parseFloat(colorVarMatch[2]) / 100;
          return Color(color).mix(Color("black"), shade);
        }
      }
      const varMatch = value.match(CSS_SIMPLE_VAR_REGEX);
      if (varMatch) {
        const color = resolveCSSVariableColor(cssVariables[varMatch[1]]);
        if (color) {
          return color;
        }
      }
    }
  } catch (e) {
    console.warn(e);
  }
  return null;
}

function replaceCSSVariables(content, isCSS) {
  if (!isCSS) {
    return content;
  }
  return content.replace(CSS_VAR_REGEX, variable => {
    const color = resolveCSSVariableColor(variable);
    if (color) {
      const [newColorName, newColor] = getBestCandidate(color);
      console.log(variable, "=>", newColor.string(), `(${newColorName})`);
      return newColor.string();
    } else {
      return variable;
    }
  });
}

function processFiles(files) {
  for (const file of files) {
    const isCSS = /\.css/.test(file);

    let content = fs.readFileSync(file, "utf-8");
    content = replaceSimpleColorValues(content, isCSS);
    content = replaceCSSVariables(content, isCSS);
    fs.writeFileSync(file, content);
  }
}

glob(
  path.join(__dirname, "..", FILE_GLOB),
  { ignore: FILE_GLOB_IGNORE },
  (err, files) => {
    if (err) {
      console.error(err);
    } else {
      processFiles(files);
    }
  },
);
