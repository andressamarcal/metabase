#!./node_modules/.bin/babel-node

const glob = require("glob");
const fs = require("fs");
const path = require("path");
const Color = require("color");
const colorDiff = require("color-diff");

const POSTCSS_CONFIG = require("../postcss.config.js");
const cssVariables =
  POSTCSS_CONFIG.plugins["postcss-cssnext"].features.customProperties.variables;
console.log(cssVariables);

// these are a bit liberal regexes but that's probably ok
const COLOR_REGEX = /(#[a-fA-F0-9]{3}([a-fA-F0-9]{3})?|(rgb|hsl)a?\(\s*\d+\s*(,\s*\d+(\.\d+)?%?\s*){2,3}\))/g;
const COLOR_REGEX_WITH_LINE = /(#[a-fA-F0-9]{3}([a-fA-F0-9]{3})?|(rgb|hsl)a?\(\s*\d+\s*(,\s*\d+(\.\d+)?%?\s*){2,3}\)).*/g;

const CSS_SIMPLE_VAR_REGEX = /^var\(([^)]+)\)$/;
const CSS_COLOR_VAR_REGEX = /^color\(var\(([^)]+)\) shade\(([^)]+)\)\)$/;
const CSS_VAR_REGEX = /var\([^)]+\)|color\(var\([^)]+\) shade\([^)]+\)\)/g;

const FILE_GLOB = process.argv[2] || "frontend/**/*.{css,js,jsx}";
const FILE_GLOB_IGNORE = [
  // "**/metabase/lib/colors.js"
];

const COLORS_CSS_PATH = "frontend/src/metabase/css/core/colors.css";

const varForName = name => `--color-${name}`;

const colors = {
  brand: Color("#509EE3"),
  accent1: Color("#9CC177"),
  accent2: Color("#A989C5"),
  accent3: Color("#EF8C8C"),
  accent4: Color("#F9D45C"),
  accent5: Color("#F1B556"),
  accent6: Color("#A6E7F3"),
  accent7: Color("#7172AD"),

  white: Color("#FFFFFF"),

  "text-dark": Color("#2E353B"),
  "text-medium": Color("#93A1AB"),
  "text-light": Color("#DCE1E4"),

  "bg-dark": Color("#EDF2F5"),
  "bg-light": Color("#F9FBFC"),

  shadow: Color("#F4F5F6"),
  border: Color("#D7DBDE"),

  success: Color("#84BB4C"),
  error: Color("#ED6E6E"),
  warning: Color("#F9CF48"),
};

const palette = Object.entries(colors).map(([name, color]) => ({
  name,
  color,
  R: color.red(),
  G: color.green(),
  B: color.blue(),
}));

function getBestCandidate(color) {
  const closest = colorDiff.closest(
    { R: color.red(), G: color.green(), B: color.blue() },
    palette,
  );
  let bestName = closest.name;
  let bestColor = closest.color;
  if (color.alpha() < 1) {
    bestColor = bestColor.alpha(color.alpha());
  }
  return [bestName, bestColor];
}

function replaceSimpleColorValues(content, isCSS) {
  return content.replace(COLOR_REGEX, color => {
    const [newColorName, newColor] = getBestCandidate(Color(color));
    if (color === newColor.string()) {
      console.log(color, `(unchanged: ${newColorName})`);
    } else {
      console.log(color, "=>", newColor.string(), `(${newColorName})`);
    }
    if (newColor.alpha < 1) {
      return newColor.string();
    } else if (!isCSS) {
      return newColor.hex();
    } else {
      return `var(${varForName(newColorName)})`;
    }
  });
}

function replaceCSSVariables(content, isCSS) {
  if (!isCSS) {
    return content;
  }
  return content.replace(CSS_VAR_REGEX, variable => {
    const color = resolveCSSVariableColor(variable);
    if (color) {
      const [newColorName, newColor] = getBestCandidate(color);
      console.log(variable, "=>", newColor.string(), `(${newColorName})`);

      if (newColor.alpha() < 1) {
        // TODO: color(var(...) alpha(...))
        return newColor.string();
      } else {
        return `var(${varForName(newColorName)})`;
      }
    } else {
      return variable;
    }
  });
}

function resolveCSSVariableColor(value) {
  try {
    if (value) {
      if (COLOR_REGEX.test(value)) {
        return Color(value);
      }
      const colorVarMatch = value.match(CSS_COLOR_VAR_REGEX);
      if (colorVarMatch) {
        const color = resolveCSSVariableColor(cssVariables[colorVarMatch[1]]);
        if (color) {
          const shade = parseFloat(colorVarMatch[2]) / 100;
          return Color(color).mix(Color("black"), shade);
        }
      }
      const varMatch = value.match(CSS_SIMPLE_VAR_REGEX);
      if (varMatch) {
        const color = resolveCSSVariableColor(cssVariables[varMatch[1]]);
        if (color) {
          return color;
        }
      }
    }
  } catch (e) {
    console.warn(e);
  }
  return null;
}

function processFiles(files) {
  for (const file of files) {
    const isCSS = /\.css/.test(file);

    let content = fs.readFileSync(file, "utf-8");
    content = replaceSimpleColorValues(content, isCSS);
    content = replaceCSSVariables(content, isCSS);
    fs.writeFileSync(file, content);
  }

  // do this last so we don't replace them
  prependColorVarsBlock();
}

function prependColorVarsBlock() {
  const colorsVarsBlock =
    `:root {\n` +
    Object.entries(colors)
      .map(([name, color]) => `  ${varForName(name)}: ${color.hex()};`)
      .join("\n") +
    `\n}\n\n`;
  fs.writeFileSync(
    COLORS_CSS_PATH,
    colorsVarsBlock + fs.readFileSync(COLORS_CSS_PATH, "utf-8"),
  );
}

glob(
  path.join(__dirname, "..", FILE_GLOB),
  { ignore: FILE_GLOB_IGNORE },
  (err, files) => {
    if (err) {
      console.error(err);
    } else {
      processFiles(files);
    }
  },
);
