#!./node_modules/.bin/babel-node

const glob = require("glob");
const fs = require("fs");
const path = require("path");
const Color = require("color");
const colorDiff = require("color-diff");

// these are a bit liberal regexes but that's probably ok
const COLOR_REGEX = /(#[a-fA-F0-9]{3}([a-fA-F0-9]{3})?|(rgb|hsl)a?\(\s*\d+\s*(,\s*\d+(\.\d+)?%?\s*){2,3}\))/g;
const COLOR_REGEX_WITH_LINE = /(#[a-fA-F0-9]{3}([a-fA-F0-9]{3})?|(rgb|hsl)a?\(\s*\d+\s*(,\s*\d+(\.\d+)?%?\s*){2,3}\)).*/g;

const FILE_GLOB = "frontend/**/*.{css,js,jsx}";
const FILE_GLOB_IGNORE = [
  // "**/metabase/lib/colors.js"
];

const candidates = {};

function addCandidate(colorName, baseColor, tints = [1]) {
  for (const tint of tints) {
    if (tint === 1) {
      candidates[colorName] = baseColor.rgb();
    } else {
      candidates[`${colorName}-${tint * 100}`] = Color("white")
        .mix(baseColor, tint)
        .rgb();
    }
  }
}

// add candidate colors, currently various tints of normal, saturated, and desaturated
// const colors = require("../frontend/src/metabase/lib/colors");
// const tints = [1, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.05, 0.02];
//
// for (const [colorName, color] of Object.entries(colors.normal)) {
//   addCandidate(colorName, Color(color), tints);
// }
// for (const [colorName, color] of Object.entries(colors.saturated)) {
//   addCandidate(colorName + "-saturated", Color(color), tints);
// }
// for (const [colorName, color] of Object.entries(colors.desaturated)) {
//   addCandidate(colorName + "-desaturated", Color(color), tints);
// }

addCandidate("brand", Color("#509EE3"));
addCandidate("accent1", Color("#9CC177"));
addCandidate("accent2", Color("#A989C5"));
addCandidate("accent3", Color("#EF8C8C"));
addCandidate("accent4", Color("#F9D45C"));
addCandidate("accent5", Color("#F1B556"));
addCandidate("accent6", Color("#A6E7F3"));
addCandidate("accent7", Color("#7172AD"));

addCandidate("white", Color("#FFFFFF"));

addCandidate("text-dark", Color("#2E353B"));
addCandidate("text-medium", Color("#93A1AB"));
addCandidate("text-light", Color("#DCE1E4"));

addCandidate("bg-dark", Color("#EDF2F5"));
addCandidate("bg-light", Color("#F9FBFC"));

addCandidate("shadow", Color("#F4F5F6"));
addCandidate("border", Color("#D7DBDE"));

addCandidate("success", Color("#84BB4C"));
addCandidate("error", Color("#ED6E6E"));
addCandidate("warning", Color("#F9CF48"));

// maybe this should weight the difference in hue more heavily?
// function colorDifference(colorA, colorB) {
//   return Math.sqrt(
//     Math.pow(colorA.red() - colorB.red(), 2) +
//       Math.pow(colorA.green() - colorB.green(), 2) +
//       Math.pow(colorA.blue() - colorB.blue(), 2),
//   );
// }

// function getBestCandidate(color) {
//   let bestName;
//   let bestDistance = Infinity;
//   for (const [candidateName, candidate] of Object.entries(candidates)) {
//     const distance = colorDifference(color, candidate);
//     if (distance < bestDistance) {
//       bestName = candidateName;
//       bestDistance = distance;
//     }
//   }
//   let bestColor = candidates[bestName];
//   if (color.alpha() < 1) {
//     bestColor = bestColor.alpha(color.alpha());
//   }
//   // console.log(color.string(), "=>", bestName, bestColor.string(), bestDistance);
//   return [bestName, bestColor];
// }

const palette = Object.entries(candidates).map(([name, color]) => ({
  name,
  color,
  R: color.red(),
  G: color.green(),
  B: color.blue(),
}));

function getBestCandidate(color) {
  const closest = colorDiff.closest(
    { R: color.red(), G: color.green(), B: color.blue() },
    palette,
  );
  let bestName = closest.name;
  let bestColor = closest.color;
  if (color.alpha() < 1) {
    bestColor = bestColor.alpha(color.alpha());
  }
  return [bestName, bestColor];
}

function processFiles(files) {
  const allMatches = [];
  const uniqueMatches = new Set();

  for (const file of files) {
    const content = fs.readFileSync(file, "utf-8");
    const modifiedContent = content.replace(COLOR_REGEX_WITH_LINE, line => {
      const names = [];
      let modifiedLine = line.replace(COLOR_REGEX, color => {
        uniqueMatches.add(color);
        allMatches.push(color);

        const [newColorName, newColor] = getBestCandidate(Color(color));
        if (color === newColor.string()) {
          console.log(color, `(unchanged: ${newColorName})`);
        } else {
          console.log(color, "=>", newColor.string(), `(${newColorName})`);
        }

        names.push(newColorName);
        return newColor.string();
      });
      // add a comment with the color name. currently disabled due to nested comments breaking some files
      // modifiedLine += /\.css/.test(file)
      //   ? " /* " + names.join(", ") + " */"
      //   : " // " + names.join(", ");
      return modifiedLine;
    });
    fs.writeFileSync(file, modifiedContent);
  }
  console.log("total", allMatches.length);
  console.log("unique", uniqueMatches.size);
}

glob(
  path.join(__dirname, "..", FILE_GLOB),
  { ignore: FILE_GLOB_IGNORE },
  (err, files) => {
    if (err) {
      console.error(err);
    } else {
      processFiles(files);
    }
  },
);
